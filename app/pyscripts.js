const files = {
    "wsserver.py": "import os\r\nimport sys\r\nimport json\r\nimport pyatv\r\nimport random\r\nimport asyncio\r\nfrom pyatv.const import InputAction\r\nimport websockets\r\n\r\nimport logging\r\nlogger = logging.getLogger('websockets')\r\nlogger.setLevel(logging.DEBUG)\r\nlogger.addHandler(logging.StreamHandler())\r\n\r\n\r\ninterface = pyatv.interface\r\npair = pyatv.pair\r\nProtocol = pyatv.const.Protocol\r\n\r\n\r\nmy_name = os.path.basename(sys.argv[0])\r\n\r\ntry:\r\n    loop = asyncio.get_event_loop()\r\nexcept RuntimeError:\r\n    loop = asyncio.new_event_loop()\r\n    asyncio.set_event_loop(loop)\r\n\r\nscan_lookup = {}\r\npairing_atv = False\r\nactive_pairing = False\r\nactive_device = False\r\nactive_remote = False\r\nactive_ws = False\r\ndefault_port = 8765\r\npairing_creds = {}\r\n\r\nclass ATVKeyboardListener(interface.KeyboardListener):\r\n    global active_ws\r\n    def focusstate_update(self, old_state, new_state):\r\n        print('Focus state changed from {0:s} to {1:s}'.format(old_state, new_state), flush=True)\r\n        if active_ws:\r\n            try:\r\n                loop.run_until_complete(sendCommand(active_ws, \"keyboard_changestate\", [old_state, new_state]))\r\n            except Exception as ex:\r\n                print (f\"change state error: {ex}\", flush=True)\r\n                \r\n\r\n\r\nasync def sendCommand (ws, command, data=[]):\r\n    r = {\"command\": command, \"data\": data}\r\n    await ws.send(json.dumps(r))\r\n\r\nasync def parseRequest(j, websocket):\r\n    global scan_lookup, pairing_atv, active_pairing, active_device, active_remote, active_ws, pairing_creds\r\n    active_ws = websocket\r\n    if \"cmd\" in j.keys():\r\n        cmd = j[\"cmd\"]\r\n    else:\r\n        return\r\n    #print (f\"got command: {cmd}\", flush=True)\r\n    \r\n    data = False\r\n    if \"data\" in j.keys():\r\n        data = j[\"data\"]\r\n    \r\n    if cmd == \"quit\":\r\n        print (\"quit command\")\r\n        await asyncio.sleep(0.5)\r\n        sys.exit(0)\r\n        return\r\n    \r\n    if cmd == \"scan\":\r\n        atvs = await pyatv.scan(loop)\r\n        ar = []\r\n        scan_lookup = {}\r\n        for atv in atvs:\r\n            txt = f\"{atv.name} ({atv.address})\"\r\n            ar.append(txt)\r\n            scan_lookup[txt] = atv\r\n\r\n        await sendCommand(websocket, \"scanResult\", ar)\r\n\r\n    if cmd == \"echo\":\r\n        await sendCommand(websocket, \"echo_reply\", data)\r\n\r\n    if cmd == \"startPair\":\r\n        print (\"startPair\")\r\n        atv = scan_lookup[data]\r\n        pairing_atv = atv\r\n        print (\"pairing atv %s\" % (atv))\r\n        pairing = await pair(atv, Protocol.AirPlay, loop)\r\n        active_pairing = pairing\r\n        await pairing.begin()\r\n\r\n    if cmd == \"finishPair1\":\r\n        print(\"finishPair %s\" % (data))\r\n        pairing = active_pairing\r\n        pairing.pin(data)\r\n        await pairing.finish()\r\n        if pairing.has_paired:\r\n            print(\"Paired with device!\")\r\n            print(\"Credentials:\", pairing.service.credentials)\r\n        else:\r\n            print(\"Did not pair with device!\")\r\n            return\r\n        creds = pairing.service.credentials\r\n        id = pairing_atv.identifier\r\n        nj = {\"credentials\": creds, \"identifier\": id}\r\n        pairing_creds = nj\r\n        await sendCommand(websocket, \"startPair2\")\r\n        #await sendCommand(websocket, \"pairCredentials1\", nj)\r\n        atv = pairing_atv\r\n        print (\"pairing atv %s\" % (atv))\r\n        pairing = await pair(atv, Protocol.Companion, loop)\r\n        active_pairing = pairing\r\n        await pairing.begin()\r\n\r\n    if cmd == \"finishPair2\":\r\n        print(\"finishPair %s\" % (data))\r\n        pairing = active_pairing\r\n        pairing.pin(data)\r\n        await pairing.finish()\r\n        if pairing.has_paired:\r\n            print(\"Paired with device!\")\r\n            print(\"Credentials:\", pairing.service.credentials)\r\n        else:\r\n            print(\"Did not pair with device!\")\r\n        pairing_creds[\"Companion\"] = pairing.service.credentials\r\n        await sendCommand(websocket, \"pairCredentials\", pairing_creds)\r\n    \r\n    \r\n    if cmd == \"finishPair\":\r\n        print(\"finishPair %s\" % (data))\r\n        pairing = active_pairing\r\n        pairing.pin(data)\r\n        await pairing.finish()\r\n        if pairing.has_paired:\r\n            print(\"Paired with device!\")\r\n            print(\"Credentials:\", pairing.service.credentials)\r\n        else:\r\n            print(\"Did not pair with device!\")\r\n        creds = pairing.service.credentials\r\n        id = pairing_atv.identifier\r\n        nj = {\"credentials\": creds, \"identifier\": id}\r\n        await sendCommand(websocket, \"pairCredentials\", nj)\r\n\r\n    if cmd == \"kbfocus\":\r\n        if not active_device:\r\n            return\r\n        kbfocus = active_device.keyboard.text_focus_state == pyatv.const.KeyboardFocusState.Focused\r\n        await sendCommand(websocket, \"kbfocus-status\", kbfocus)\r\n    \r\n    if cmd == \"settext\":\r\n        text = data[\"text\"]\r\n        if active_device.keyboard.text_focus_state != pyatv.const.KeyboardFocusState.Focused:\r\n            return\r\n        await active_device.keyboard.text_set(text)\r\n    \r\n    if cmd == \"gettext\":\r\n        print (f\"gettext focus compare {active_device.keyboard.text_focus_state} == {pyatv.const.KeyboardFocusState.Focused}\", flush=True)\r\n        if active_device.keyboard.text_focus_state != pyatv.const.KeyboardFocusState.Focused:\r\n            return\r\n        ctext = await active_device.keyboard.text_get()\r\n        print (f\"Current text: {ctext}\", flush=True)\r\n        await sendCommand(websocket, \"current-text\", ctext)\r\n    \r\n    if cmd == \"connect\":\r\n        id = data[\"identifier\"]\r\n        creds = data[\"credentials\"]\r\n        stored_credentials = { Protocol.AirPlay: creds }\r\n        if \"Companion\" in data.keys():\r\n            companion_creds = data[\"Companion\"]\r\n            stored_credentials[Protocol.Companion] = companion_creds\r\n        \r\n        print (\"stored_credentials %s\" % (stored_credentials))\r\n        atvs = await pyatv.scan(loop, identifier=id)\r\n        atv = atvs[0]\r\n        for protocol, credentials in stored_credentials.items():\r\n            print (\"Setting protocol %s with credentials %s\" % (str(protocol), credentials))\r\n            atv.set_credentials(protocol, credentials)\r\n        try:\r\n            device = await pyatv.connect(atv, loop)\r\n            remote = device.remote_control\r\n            active_device = device\r\n            active_remote = remote\r\n            kblistener = ATVKeyboardListener()\r\n            device.keyboard.listener = kblistener\r\n            await sendCommand(websocket, \"connected\")\r\n        except Exception as ex:\r\n            print (\"Failed to connect\")\r\n            await sendCommand(websocket, \"connection_failure\")\r\n    \r\n    if cmd == \"is_connected\":\r\n        ic = \"true\" if active_remote else \"false\"\r\n        await sendCommand(websocket, \"is_connected\", ic)\r\n        #await active_remote.menu()\r\n    \r\n    if cmd == \"key\":\r\n        valid_keys = ['play_pause', 'left', 'right', 'down', 'up', 'select', 'menu', 'top_menu', 'home', 'home_hold', 'skip_backward', 'skip_forward', 'volume_up', 'volume_down']\r\n        no_action_keys = ['volume_up', 'volume_down', 'play_pause', 'home_hold']\r\n        #taction = InputAction[\"SingleTap\"]\r\n        taction = False\r\n        key = data\r\n        if not isinstance(data, str):\r\n            key = data['key']\r\n            taction = InputAction[data['taction']]\r\n    \r\n        if key in valid_keys:\r\n            if key in no_action_keys or (not taction):\r\n                r = await getattr(active_remote, key)()\r\n            else:\r\n                r = await getattr(active_remote, key)(taction)\r\n            #print (r)\r\n\r\nasync def close_active_device():\r\n    try:\r\n        if active_device:\r\n            await active_device.close()\r\n    except Exception as ex:\r\n        print (\"Error closing active_device: %s\" %(ex))\r\n\r\nasync def reset_globals():\r\n    global scan_lookup, pairing_atv, active_pairing, active_device, active_remote, active_ws\r\n    print (\"Resetting global variables\")\r\n    scan_lookup = {}\r\n    \r\n    pairing_atv = False\r\n    active_pairing = False\r\n    active_device = False\r\n    active_remote = False\r\n    active_ws = False\r\n\r\nkeep_running = True\r\n\r\n\r\nasync def check_exit_file():\r\n    global keep_running\r\n    if os.path.exists('stopserver'):\r\n        os.unlink('stopserver')\r\n\r\n    while keep_running:\r\n        await asyncio.sleep(0.5)\r\n        fe = os.path.exists('stopserver')\r\n        txt = \"found\" if fe else \"not found\"\r\n        #print (\"stopserver %s\" % (txt), flush=True)\r\n        if fe:\r\n            print (\"exiting\")\r\n            keep_running = False\r\n            os.unlink('stopserver')\r\n            sys.exit(0)\r\n\r\n\r\nasync def ws_main(websocket):\r\n    #await reset_globals()\r\n    await close_active_device()\r\n    async for message in websocket:\r\n        try:\r\n            j = json.loads(message)\r\n        except Exception as ex:\r\n            print (\"Error parsing message: %s\\n%s\" % (str(ex), message))\r\n            continue\r\n        \r\n        await parseRequest(j, websocket)\r\n\r\nasync def main(port):\r\n    global keep_running\r\n    width = 80\r\n    txt = \"%s WebSocket - ATV Server\" % (my_name)\r\n    print (\"=\"*width)\r\n    print (txt.center(width))\r\n    print (\"=\"*width, flush=True)\r\n    task = asyncio.create_task(check_exit_file())\r\n\r\n    async with websockets.serve(ws_main, \"localhost\", port):\r\n        try:\r\n            await asyncio.Future()  # run forever\r\n        except Exception as ex:\r\n            print (ex)\r\n            sys.exit(0)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    args = sys.argv[1:]\r\n    port = default_port\r\n    if len(args) > 0:\r\n        if args[0] in [\"-h\", \"--help\", \"-?\", \"/?\"]:\r\n            print (\"Usage: %s (port_number)\\n\\n Port number by default is %d\" % (my_name, default_port))\r\n        port = int(args[0])\r\n\r\n    asyncio.set_event_loop(loop)\r\n    loop.run_until_complete(main(port))\r\n\r\n",
    "start_server.bat": "@echo off\r\nset INSTALL_LOG=atv_pip_install.log\r\nset MY_PATH=%~dp0\r\ncd /d %MY_PATH%\r\n\r\nif not exist env (\r\n    echo ATVRemote - Python install started %DATE% %TIME% >> %INSTALL_LOG%\r\n    echo > setting_up_python\r\n    \r\n    REM Check if uv is installed (it's much faster)\r\n    where uv >nul 2>&1\r\n    if not errorlevel 1 (\r\n        echo Using uv for virtual environment setup >> %INSTALL_LOG%\r\n        uv venv env >> %INSTALL_LOG% 2>&1\r\n        call env\\Scripts\\activate.bat\r\n        uv pip install websockets pyatv >> %INSTALL_LOG% 2>&1\r\n    ) else (\r\n        echo Using standard Python venv >> %INSTALL_LOG%\r\n        python -m venv env >> %INSTALL_LOG% 2>&1\r\n        call env\\Scripts\\activate.bat\r\n        python -m pip install --upgrade pip >> %INSTALL_LOG% 2>&1\r\n        python -m pip install websockets pyatv >> %INSTALL_LOG% 2>&1\r\n    )\r\n\r\n    echo ATVRemote - Python install ended %DATE% %TIME% >> %INSTALL_LOG%\r\n    echo ================================================== >> %INSTALL_LOG%\r\n) else (\r\n    call env\\Scripts\\activate.bat\r\n)\r\n\r\n:kill_proc\r\nfor /f \"tokens=2 delims= \" %%A in ('tasklist /FI \"IMAGENAME eq python.exe\" /NH') do (\r\n    tasklist /FI \"WINDOWTITLE eq wsserver.py\" | findstr wsserver.py >nul\r\n    if not errorlevel 1 (\r\n        echo Killing %%A\r\n        taskkill /PID %%A /F\r\n    )\r\n)\r\nif exist setting_up_python del setting_up_python\r\npython wsserver.py\r\n",
    "start_server.sh": "#!/bin/bash\nINSTALL_LOG=\"atv_pip_install.log\"\nMY_PATH=$(dirname \"$0\")\ncd \"$MY_PATH\"\nif [[ ! -d env ]]; then\n    dt=$(date)\n    echo \"ATVRemote - Python install started $dt\" >> $INSTALL_LOG\n    touch setting_up_python\n    \n    # Check if uv is installed (it's faster in my testing)\n    if command -v uv &> /dev/null; then\n        echo \"Using uv for virtual environment setup\" >> $INSTALL_LOG\n        uv venv env | tee -a $INSTALL_LOG\n        source env/bin/activate\n        uv pip install websockets pyatv | tee -a $INSTALL_LOG\n    else\n        echo \"Using standard Python venv\" >> $INSTALL_LOG\n        python3 -m venv env | tee -a $INSTALL_LOG\n        source env/bin/activate\n        python -m pip install --upgrade pip | tee -a $INSTALL_LOG\n        python -m pip install websockets pyatv | tee -a $INSTALL_LOG\n    fi\n    \n    dt=$(date)\n    echo \"ATVRemote - Python install ended $dt\" >> $INSTALL_LOG\n    echo \"==================================================\" >> $INSTALL_LOG\nelse\n    source env/bin/activate\nfi\n\nfunction kill_proc () {\n    for p in $(ps ax | grep -v grep | grep wsserver.py | awk '{print $1}'); do\n        echo \"Killing $p\"\n        kill $1 $p\n    done\n}\nkill_proc\nkill_proc \"-9\"\n[[ -f setting_up_python ]] && rm setting_up_python\npython wsserver.py"
};

exports.files = files;
