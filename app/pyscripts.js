const files = {
    "wsserver.py": "import os\nimport sys\nimport json\n\n## Add pyatv to path for local development (fewer red lines)\n#sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'pyatv'))\n\nimport pyatv\nimport random\nimport asyncio\nfrom pyatv.const import InputAction\nfrom pyatv import const as pyatv_const\nimport websockets\n\nimport logging\nlogger = logging.getLogger('websockets')\nlogger.setLevel(logging.DEBUG)\nlogger.addHandler(logging.StreamHandler())\n\n\ninterface = pyatv.interface\npair = pyatv.pair\nProtocol = pyatv_const.Protocol\n\n\nmy_name = os.path.basename(sys.argv[0])\n\ntry:\n    loop = asyncio.get_event_loop()\nexcept RuntimeError:\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n\nscan_lookup = {}\nfilter_atvs = True # Should only return ATVs and not other device types (HomePods, Macs, etc)\npairing_atv = False\nactive_pairing = False\nactive_device = False\nactive_remote = False\nactive_ws = False\ndefault_port = 8765\npairing_creds = {}\n\n# Store the AppleTVConfig for reconnection using pyatv's built-in features\ncurrent_config = None\n\nclass ATVKeyboardListener(interface.KeyboardListener):\n    global active_ws\n    def focusstate_update(self, old_state, new_state):\n        print('Focus state changed from {0:s} to {1:s}'.format(old_state, new_state), flush=True)\n        if active_ws:\n            try:\n                loop.run_until_complete(sendCommand(active_ws, \"keyboard_changestate\", [old_state, new_state]))\n            except Exception as ex:\n                print (f\"change state error: {ex}\", flush=True)\n\nclass ATVConnectionListener(interface.DeviceListener):\n    \"\"\"Listener for Apple TV connection state changes.\"\"\"\n    \n    def connection_lost(self, exception):\n        \"\"\"Called when connection is lost.\"\"\"\n        global active_device, active_remote, current_config, active_ws\n        print(f\"Connection lost: {exception}\", flush=True)\n        \n        # Only attempt reconnection if we have a valid config and were previously connected\n        if current_config and active_device and active_remote:\n            if active_ws:\n                try:\n                    loop.run_until_complete(sendCommand(active_ws, \"connection_lost\"))\n                except Exception as ex:\n                    print(f\"Failed to notify client of connection loss: {ex}\", flush=True)\n            \n            # Attempt automatic reconnection in background\n            loop.create_task(attempt_reconnection())\n        else:\n            # No valid config to reconnect with, just reset state\n            active_device = False\n            active_remote = False\n    \n    def connection_closed(self):\n        \"\"\"Called when connection is closed.\"\"\"\n        global active_device, active_remote, active_ws\n        print(\"Connection closed\", flush=True)\n        \n        # Don't attempt reconnection on clean close - user likely disconnected intentionally\n        active_device = False\n        active_remote = False\n        \n        if active_ws:\n            try:\n                loop.run_until_complete(sendCommand(active_ws, \"connection_closed\"))\n            except Exception as ex:\n                print(f\"Failed to notify client of connection close: {ex}\", flush=True)\n\nclass ATVPowerListener(interface.PowerListener):\n    \"\"\"Listener for Apple TV power state changes.\"\"\"\n    \n    def powerstate_update(self, old_state, new_state):\n        \"\"\"Called when power state changes.\"\"\"\n        print(f'Power state changed from {old_state} to {new_state}', flush=True)\n        if active_ws:\n            try:\n                loop.run_until_complete(sendCommand(active_ws, \"power_state_changed\", {\n                    \"old_state\": str(old_state),\n                    \"new_state\": str(new_state)\n                }))\n            except Exception as ex:\n                print(f\"Power state error: {ex}\", flush=True)\n                \n\n\nasync def sendCommand (ws, command, data=[]):\n    r = {\"command\": command, \"data\": data}\n    await ws.send(json.dumps(r))\n\nasync def attempt_reconnection():\n    \"\"\"Attempt to reconnect using pyatv's built-in reconnection.\"\"\"\n    global active_device, active_remote, current_config, active_ws\n    \n    if not current_config:\n        print(\"No config available for reconnection\", flush=True)\n        return False\n    \n    # Don't attempt reconnection if we're in the middle of pairing\n    if active_pairing or pairing_atv:\n        print(\"Skipping reconnection - pairing in progress\", flush=True)\n        return False\n    \n    try:\n        print(\"Attempting automatic reconnection...\", flush=True)\n        \n        # Close old connection first\n        if active_device:\n            try:\n                await active_device.close()\n            except:\n                pass\n        active_device = False\n        active_remote = False\n        \n        # Reconnect using stored config\n        device = await pyatv.connect(current_config, loop)\n        remote = device.remote_control\n        active_device = device\n        active_remote = remote\n        \n        # Set up listeners again\n        device.listener = ATVConnectionListener()\n        device.power.listener = ATVPowerListener()\n        kblistener = ATVKeyboardListener()\n        device.keyboard.listener = kblistener\n        \n        print(\"Automatic reconnection successful\", flush=True)\n        \n        if active_ws:\n            await sendCommand(active_ws, \"reconnected\")\n        \n        return True\n        \n    except Exception as ex:\n        print(f\"Automatic reconnection failed: {ex}\", flush=True)\n        active_device = False\n        active_remote = False\n        \n        if active_ws:\n            await sendCommand(active_ws, \"reconnection_failed\")\n        \n        return False\n\nasync def parseRequest(j, websocket):\n    global scan_lookup, pairing_atv, active_pairing, active_device, active_remote, active_ws, pairing_creds\n    active_ws = websocket\n    if \"cmd\" in j.keys():\n        cmd = j[\"cmd\"]\n    else:\n        return\n    #print (f\"got command: {cmd}\", flush=True)\n    \n    data = False\n    if \"data\" in j.keys():\n        data = j[\"data\"]\n    \n    if cmd == \"quit\":\n        print (\"quit command\")\n        await close_active_device()\n        await asyncio.sleep(0.5)\n        sys.exit(0)\n        return\n    \n    if cmd == \"disconnect\":\n        print (\"disconnect command\")\n        await close_active_device()\n        await reset_globals()\n        await sendCommand(websocket, \"disconnected\")\n        return\n    \n    if cmd == \"scan\":\n        atvs = await pyatv.scan(loop)\n        ar = []\n        scan_lookup = {}\n        if filter_atvs:\n            atvs = [x for x in atvs if \"TV\" in x.device_info.model_str]\n        for atv in atvs:\n            txt = f\"{atv.name} ({atv.address})\"\n            ar.append(txt)\n            scan_lookup[txt] = atv\n\n        await sendCommand(websocket, \"scanResult\", ar)\n\n    if cmd == \"echo\":\n        await sendCommand(websocket, \"echo_reply\", data)\n\n    if cmd == \"startPair\":\n        print (\"startPair\")\n        atv = scan_lookup[data]\n        pairing_atv = atv\n        print (\"pairing atv %s\" % (atv))\n        pairing = await pair(atv, Protocol.AirPlay, loop)\n        active_pairing = pairing\n        await pairing.begin()\n\n    if cmd == \"finishPair1\":\n        print(\"finishPair %s\" % (data))\n        pairing = active_pairing\n        pairing.pin(data)\n        await pairing.finish()\n        if pairing.has_paired:\n            print(\"Paired with device!\")\n            print(\"Credentials:\", pairing.service.credentials)\n        else:\n            print(\"Did not pair with device!\")\n            return\n        creds = pairing.service.credentials\n        id = pairing_atv.identifier\n        nj = {\"credentials\": creds, \"identifier\": id}\n        pairing_creds = nj\n        await sendCommand(websocket, \"startPair2\")\n        #await sendCommand(websocket, \"pairCredentials1\", nj)\n        atv = pairing_atv\n        print (\"pairing atv %s\" % (atv))\n        pairing = await pair(atv, Protocol.Companion, loop)\n        active_pairing = pairing\n        await pairing.begin()\n\n    if cmd == \"finishPair2\":\n        print(\"finishPair %s\" % (data))\n        pairing = active_pairing\n        pairing.pin(data)\n        await pairing.finish()\n        if pairing.has_paired:\n            print(\"Paired with device!\")\n            print(\"Credentials:\", pairing.service.credentials)\n        else:\n            print(\"Did not pair with device!\")\n        pairing_creds[\"Companion\"] = pairing.service.credentials\n        await sendCommand(websocket, \"pairCredentials\", pairing_creds)\n    \n    \n    if cmd == \"finishPair\":\n        print(\"finishPair %s\" % (data))\n        pairing = active_pairing\n        pairing.pin(data)\n        await pairing.finish()\n        if pairing.has_paired:\n            print(\"Paired with device!\")\n            print(\"Credentials:\", pairing.service.credentials)\n        else:\n            print(\"Did not pair with device!\")\n        creds = pairing.service.credentials\n        id = pairing_atv.identifier\n        nj = {\"credentials\": creds, \"identifier\": id}\n        await sendCommand(websocket, \"pairCredentials\", nj)\n\n    if cmd == \"kbfocus\":\n        if not active_device:\n            return\n        kbfocus = active_device.keyboard.text_focus_state == pyatv_const.KeyboardFocusState.Focused\n        await sendCommand(websocket, \"kbfocus-status\", kbfocus)\n    \n    if cmd == \"settext\":\n        text = data[\"text\"]\n        if active_device.keyboard.text_focus_state != pyatv_const.KeyboardFocusState.Focused:\n            return\n        await active_device.keyboard.text_set(text)\n    \n    if cmd == \"gettext\":\n        print (f\"gettext focus compare {active_device.keyboard.text_focus_state} == {pyatv_const.KeyboardFocusState.Focused}\", flush=True)\n        if active_device.keyboard.text_focus_state != pyatv_const.KeyboardFocusState.Focused:\n            return\n        ctext = await active_device.keyboard.text_get()\n        print (f\"Current text: {ctext}\", flush=True)\n        await sendCommand(websocket, \"current-text\", ctext)\n    \n    if cmd == \"connect\":\n        id = data[\"identifier\"]\n        creds = data[\"credentials\"]\n        stored_credentials = { Protocol.AirPlay: creds }\n        if \"Companion\" in data.keys():\n            companion_creds = data[\"Companion\"]\n            stored_credentials[Protocol.Companion] = companion_creds\n        \n        print (\"stored_credentials %s\" % (stored_credentials))\n        atvs = await pyatv.scan(loop, identifier=id)\n        if not atvs:\n            print(\"No Apple TV found with the specified identifier\")\n            await sendCommand(websocket, \"connection_failure\")\n            return\n            \n        atv = atvs[0]\n        \n        # Set up credentials on the scanned config\n        for protocol, credentials in stored_credentials.items():\n            print (\"Setting protocol %s with credentials %s\" % (str(protocol), credentials))\n            atv.set_credentials(protocol, credentials)\n            \n        try:\n            # Connect to device\n            device = await pyatv.connect(atv, loop)\n            remote = device.remote_control\n            active_device = device\n            active_remote = remote\n            \n            # Store config for potential reconnection (only after successful connection)\n            global current_config\n            current_config = atv\n            \n            # Set up keyboard listener\n            kblistener = ATVKeyboardListener()\n            device.keyboard.listener = kblistener\n            \n            # Set up connection and power listeners (only after successful connection)\n            device.listener = ATVConnectionListener()\n            device.power.listener = ATVPowerListener()\n            \n            await sendCommand(websocket, \"connected\")\n            \n        except Exception as ex:\n            print(f\"Failed to connect: {ex}\")\n            await sendCommand(websocket, \"connection_failure\")\n    \n    if cmd == \"is_connected\":\n        # Simple check if we have active device and remote\n        ic = \"true\" if (active_remote and active_device) else \"false\"\n        await sendCommand(websocket, \"is_connected\", ic)\n        \n    if cmd == \"ping_device\":\n        # Simple ping command - just check if we have an active connection\n        if active_remote and active_device:\n            await sendCommand(websocket, \"ping_result\", \"connected\")\n        else:\n            await sendCommand(websocket, \"ping_result\", \"not_connected\")\n    \n    if cmd == \"key\":\n        if not active_remote or not active_device:\n            await sendCommand(websocket, \"command_failed\", \"not_connected\")\n            return\n            \n        valid_keys = ['play_pause', 'left', 'right', 'down', 'up', 'select', 'menu', 'top_menu', 'home', 'home_hold', 'skip_backward', 'skip_forward', 'volume_up', 'volume_down', 'suspend', 'wakeup', 'siri']\n        no_action_keys = ['volume_up', 'volume_down', 'play_pause', 'home_hold', 'suspend', 'wakeup', 'siri']\n        #taction = InputAction[\"SingleTap\"]\n        taction = False\n        key = data\n        if not isinstance(data, str):\n            key = data['key']\n            taction = InputAction[data['taction']]\n    \n        if key in valid_keys:\n            try:\n                if key in no_action_keys or (not taction):\n                    r = await getattr(active_remote, key)()\n                else:\n                    r = await getattr(active_remote, key)(taction)\n                #print (r)\n            except Exception as ex:\n                print(f\"Command execution failed: {ex}\", flush=True)\n                await sendCommand(websocket, \"command_failed\", str(ex))\n\nasync def close_active_device():\n    global active_device, active_remote\n    try:\n        if active_device:\n            await active_device.close()\n            active_device = False\n            active_remote = False\n    except Exception as ex:\n        print (\"Error closing active_device: %s\" %(ex))\n\nasync def reset_globals():\n    global scan_lookup, pairing_atv, active_pairing, active_device, active_remote, active_ws\n    global current_config\n    print (\"Resetting global variables\")\n    scan_lookup = {}\n    \n    pairing_atv = False\n    active_pairing = False\n    active_device = False\n    active_remote = False\n    active_ws = False\n    current_config = None  # Clear config to prevent unwanted reconnection attempts\n\nkeep_running = True\n\n\nasync def check_exit_file():\n    global keep_running\n    if os.path.exists('stopserver'):\n        os.unlink('stopserver')\n\n    while keep_running:\n        await asyncio.sleep(0.5)\n        fe = os.path.exists('stopserver')\n        txt = \"found\" if fe else \"not found\"\n        #print (\"stopserver %s\" % (txt), flush=True)\n        if fe:\n            print (\"exiting\")\n            keep_running = False\n            os.unlink('stopserver')\n            sys.exit(0)\n\n\nasync def ws_main(websocket):\n    global active_ws\n    active_ws = websocket\n    \n    try:\n        async for message in websocket:\n            try:\n                j = json.loads(message)\n            except Exception as ex:\n                print (\"Error parsing message: %s\\n%s\" % (str(ex), message))\n                continue\n            \n            await parseRequest(j, websocket)\n    except Exception as ex:\n        # Handle various connection closed scenarios\n        if \"ConnectionClosed\" in str(type(ex)) or \"connection closed\" in str(ex).lower():\n            print(\"WebSocket connection closed\", flush=True)\n        else:\n            print(f\"WebSocket error: {ex}\", flush=True)\n    finally:\n        # Clean up when client disconnects but keep Apple TV connection alive\n        if active_ws == websocket:\n            active_ws = False\n            # Don't close the Apple TV connection - keep it alive for reconnecting clients\n\nasync def main(port):\n    global keep_running\n    width = 80\n    txt = \"%s WebSocket - ATV Server\" % (my_name)\n    print (\"=\"*width)\n    print (txt.center(width))\n    print (\"=\"*width, flush=True)\n    task = asyncio.create_task(check_exit_file())\n\n    async with websockets.serve(ws_main, \"localhost\", port):\n        try:\n            await asyncio.Future()  # run forever\n        except Exception as ex:\n            print (ex)\n            sys.exit(0)\n\n\n\nif __name__ == \"__main__\":\n    args = sys.argv[1:]\n    port = default_port\n    if len(args) > 0:\n        if args[0] in [\"-h\", \"--help\", \"-?\", \"/?\"]:\n            print (\"Usage: %s (port_number)\\n\\n Port number by default is %d\" % (my_name, default_port))\n        port = int(args[0])\n\n    asyncio.set_event_loop(loop)\n    loop.run_until_complete(main(port))\n\n",
    "start_server.bat": "@echo off\r\nset INSTALL_LOG=atv_pip_install.log\r\nset MY_PATH=%~dp0\r\ncd /d %MY_PATH%\r\n\r\nif not exist env (\r\n    echo ATVRemote - Python install started %DATE% %TIME% >> %INSTALL_LOG%\r\n    echo > setting_up_python\r\n    \r\n    REM Check if uv is installed\r\n    where uv >nul 2>&1\r\n    if not errorlevel 1 (\r\n        echo Using uv for virtual environment setup >> %INSTALL_LOG%\r\n        uv venv env >> %INSTALL_LOG% 2>&1\r\n        call env\\Scripts\\activate.bat\r\n        if exist requirements.txt (\r\n            echo Installing from requirements.txt >> %INSTALL_LOG%\r\n            uv pip install -r requirements.txt >> %INSTALL_LOG% 2>&1\r\n        ) else (\r\n            echo Installing websockets and pyatv >> %INSTALL_LOG%\r\n            uv pip install websockets pyatv >> %INSTALL_LOG% 2>&1\r\n        )\r\n    ) else (\r\n        echo Using standard Python venv >> %INSTALL_LOG%\r\n        python -m venv env >> %INSTALL_LOG% 2>&1\r\n        call env\\Scripts\\activate.bat\r\n        python -m pip install --upgrade pip >> %INSTALL_LOG% 2>&1\r\n        if exist requirements.txt (\r\n            echo Installing from requirements.txt >> %INSTALL_LOG%\r\n            python -m pip install -r requirements.txt >> %INSTALL_LOG% 2>&1\r\n        ) else (\r\n            echo Installing websockets and pyatv >> %INSTALL_LOG%\r\n            python -m pip install websockets pyatv >> %INSTALL_LOG% 2>&1\r\n        )\r\n        \r\n    )\r\n\r\n    echo ATVRemote - Python install ended %DATE% %TIME% >> %INSTALL_LOG%\r\n    echo ================================================== >> %INSTALL_LOG%\r\n) else (\r\n    call env\\Scripts\\activate.bat\r\n)\r\n\r\n:kill_proc\r\nfor /f \"tokens=2 delims= \" %%A in ('tasklist /FI \"IMAGENAME eq python.exe\" /NH') do (\r\n    tasklist /FI \"WINDOWTITLE eq wsserver.py\" | findstr wsserver.py >nul\r\n    if not errorlevel 1 (\r\n        echo Killing %%A\r\n        taskkill /PID %%A /F\r\n    )\r\n)\r\nif exist setting_up_python del setting_up_python\r\npython wsserver.py\r\n",
    "start_server.sh": "#!/bin/bash\nINSTALL_LOG=\"atv_pip_install.log\"\nMY_PATH=$(dirname \"$0\")\ncd \"$MY_PATH\"\nif [[ ! -d env ]]; then\n    dt=$(date)\n    echo \"ATVRemote - Python install started $dt\" >> $INSTALL_LOG\n    touch setting_up_python\n    \n    # Check if uv is installed (it's faster in my testing)\n    if command -v uv &> /dev/null; then\n        echo \"Using uv for virtual environment setup\" >> $INSTALL_LOG\n        uv venv env | tee -a $INSTALL_LOG\n        source env/bin/activate\n        if [[ -f requirements.txt ]]; then\n            echo \"Installing from requirements.txt\" >> $INSTALL_LOG\n            uv pip install -r requirements.txt | tee -a $INSTALL_LOG\n        else\n            echo \"Installing websockets and pyatv\" >> $INSTALL_LOG\n            uv pip install websockets pyatv | tee -a $INSTALL_LOG\n        fi\n        \n    else\n        echo \"Using standard Python venv\" >> $INSTALL_LOG\n        python3 -m venv env | tee -a $INSTALL_LOG\n        source env/bin/activate\n        python -m pip install --upgrade pip | tee -a $INSTALL_LOG\n        if [[ -f requirements.txt ]]; then\n            echo \"Installing from requirements.txt\" >> $INSTALL_LOG\n            python -m pip install -r requirements.txt | tee -a $INSTALL_LOG\n        else\n            echo \"Installing websockets and pyatv\" >> $INSTALL_LOG\n            python -m pip install websockets pyatv | tee -a $INSTALL_LOG\n        fi\n    fi\n    \n    dt=$(date)\n    echo \"ATVRemote - Python install ended $dt\" >> $INSTALL_LOG\n    echo \"==================================================\" >> $INSTALL_LOG\nelse\n    source env/bin/activate\nfi\n\nfunction kill_proc () {\n    for p in $(ps ax | grep -v grep | grep wsserver.py | awk '{print $1}'); do\n        echo \"Killing $p\"\n        kill $1 $p\n    done\n}\nkill_proc\nkill_proc \"-9\"\n[[ -f setting_up_python ]] && rm setting_up_python\npython wsserver.py"
};

exports.files = files;
